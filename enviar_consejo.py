import datetime
import random
from consejos_diarios import consejos
from calcular_intervalos import calcular_intervalos_optimos
from geopy.geocoders import Nominatim
from timezonefinder import TimezoneFinder
import requests
from telegram import Bot
import asyncio
import os

# ‚ûï Funci√≥n para detectar ubicaci√≥n con fallback a M√°laga
def obtener_ubicacion():
    try:
        ip = requests.get("https://api.ipify.org").text
        response = requests.get(f"https://ipapi.co/{ip}/json/")
        data = response.json()

        ciudad = data.get("city")
        lat = data.get("latitude")
        lon = data.get("longitude")

        if ciudad.lower() != "m√°laga":
            raise ValueError("Ubicaci√≥n distinta de M√°laga")

        print(f"‚úÖ Ubicaci√≥n detectada por IP: {ciudad} ({lat}, {lon})")

    except:
        print("‚ö†Ô∏è Error o ubicaci√≥n no deseada (Ubicaci√≥n distinta de M√°laga). Usando fallback a M√°laga.")
        ciudad = "M√°laga"
        geolocator = Nominatim(user_agent="bot_inmune_diario")
        location = geolocator.geocode(ciudad)
        lat = location.latitude
        lon = location.longitude

    try:
        tf = TimezoneFinder()
        zona_horaria = tf.timezone_at(lat=lat, lng=lon)
    except:
        zona_horaria = "Europe/Madrid"

    print(f"‚úÖ Ubicaci√≥n final: {ciudad} ({lat:.4f}, {lon:.4f}) - Zona horaria: {zona_horaria}")

    return {
        "latitud": lat,
        "longitud": lon,
        "ciudad": ciudad,
        "timezone": zona_horaria
    }

# Obtener ubicaci√≥n
ubicacion = obtener_ubicacion()
if not ubicacion:
    print("Error: No se pudo obtener la ubicaci√≥n correctamente.")
    exit()

lat = ubicacion["latitud"]
lon = ubicacion["longitud"]
timezone_str = ubicacion["timezone"]

# D√≠a de la semana actual
dia_semana = datetime.datetime.now().weekday()

# Elegir consejo aleatorio (con texto + referencia)
consejo_dia = random.sample(consejos[dia_semana], 2)
texto_consejo = next(x for x in consejo_dia if not x.startswith("üìö"))
referencia = next(x for x in consejo_dia if x.startswith("üìö"))

# Calcular intervalos solares seguros
intervalos = calcular_intervalos_optimos(lat, lon, datetime.datetime.now(), timezone_str)
antes, despues = intervalos

# Construir mensaje
mensaje = f"{texto_consejo}\n\n{referencia}\n\nüåû Intervalos solares seguros para producir vit. D hoy ({ubicacion['ciudad']}):\n"

if antes:
    mensaje += f"üåÖ Ma√±ana: {antes[0]} - {antes[-1]}\n"
if despues:
    mensaje += f"üåá Tarde: {despues[0]} - {despues[-1]}"
if not antes and not despues:
    mensaje += "Hoy no hay intervalos seguros con el Sol entre 30¬∞ y 40¬∞ de elevaci√≥n."

# ‚úâÔ∏è Enviar por Telegram
async def enviar_mensaje_telegram(texto):
    bot_token = os.getenv("BOT_TOKEN")
    chat_id = os.getenv("CHAT_ID")
    if not bot_token or not chat_id:
        print("Faltan BOT_TOKEN o CHAT_ID")
        return
    try:
        bot = Bot(token=bot_token)
        await bot.send_message(chat_id=chat_id, text=texto)
        print("‚úÖ Mensaje enviado por Telegram correctamente.")
    except Exception as e:
        print(f"‚ùå Error al enviar mensaje: {e}")

# Ejecutar
asyncio.run(enviar_mensaje_telegram(mensaje))

